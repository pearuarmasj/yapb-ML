#define DIK_ESCAPE          0x01
#define DIK_1               0x02
#define DIK_2               0x03
#define DIK_3               0x04
#define DIK_4               0x05
#define DIK_5               0x06
#define DIK_6               0x07
#define DIK_7               0x08
#define DIK_8               0x09
#define DIK_9               0x0A
#define DIK_0               0x0B
#define DIK_MINUS           0x0C    /* - on main keyboard */
#define DIK_EQUALS          0x0D
#define DIK_BACK            0x0E    /* backspace */
#define DIK_TAB             0x0F
#define DIK_Q               0x10
#define DIK_W               0x11
#define DIK_E               0x12
#define DIK_R               0x13
#define DIK_T               0x14
#define DIK_Y               0x15
#define DIK_U               0x16
#define DIK_I               0x17
#define DIK_O               0x18
#define DIK_P               0x19
#define DIK_LBRACKET        0x1A
#define DIK_RBRACKET        0x1B
#define DIK_RETURN          0x1C    /* Enter on main keyboard */
#define DIK_LCONTROL        0x1D
#define DIK_A               0x1E
#define DIK_S               0x1F
#define DIK_D               0x20
#define DIK_F               0x21
#define DIK_G               0x22
#define DIK_H               0x23
#define DIK_J               0x24
#define DIK_K               0x25
#define DIK_L               0x26
#define DIK_SEMICOLON       0x27
#define DIK_APOSTROPHE      0x28
#define DIK_GRAVE           0x29    /* accent grave */
#define DIK_LSHIFT          0x2A
#define DIK_BACKSLASH       0x2B
#define DIK_Z               0x2C
#define DIK_X               0x2D
#define DIK_C               0x2E
#define DIK_V               0x2F
#define DIK_B               0x30
#define DIK_N               0x31
#define DIK_M               0x32
#define DIK_COMMA           0x33
#define DIK_PERIOD          0x34    /* . on main keyboard */
#define DIK_SLASH           0x35    /* / on main keyboard */
#define DIK_RSHIFT          0x36
#define DIK_MULTIPLY        0x37    /* * on numeric keypad */
#define DIK_LMENU           0x38    /* left Alt */
#define DIK_SPACE           0x39
#define DIK_CAPITAL         0x3A
#define DIK_F1              0x3B
#define DIK_F2              0x3C
#define DIK_F3              0x3D
#define DIK_F4              0x3E
#define DIK_F5              0x3F
#define DIK_F6              0x40
#define DIK_F7              0x41
#define DIK_F8              0x42
#define DIK_F9              0x43
#define DIK_F10             0x44
#define DIK_NUMLOCK         0x45
#define DIK_SCROLL          0x46    /* Scroll Lock */
#define DIK_NUMPAD7         0x47
#define DIK_NUMPAD8         0x48
#define DIK_NUMPAD9         0x49
#define DIK_SUBTRACT        0x4A    /* - on numeric keypad */
#define DIK_NUMPAD4         0x4B
#define DIK_NUMPAD5         0x4C
#define DIK_NUMPAD6         0x4D
#define DIK_ADD             0x4E    /* + on numeric keypad */
#define DIK_NUMPAD1         0x4F
#define DIK_NUMPAD2         0x50
#define DIK_NUMPAD3         0x51
#define DIK_NUMPAD0         0x52
#define DIK_DECIMAL         0x53    /* . on numeric keypad */
#define DIK_OEM_102         0x56    /* <> or \| on RT 102-key keyboard (Non-U.S.) */
#define DIK_F11             0x57
#define DIK_F12             0x58
#define DIK_F13             0x64    /*                     (NEC PC98) */
#define DIK_F14             0x65    /*                     (NEC PC98) */
#define DIK_F15             0x66    /*                     (NEC PC98) */
#define DIK_KANA            0x70    /* (Japanese keyboard)            */
#define DIK_ABNT_C1         0x73    /* /? on Brazilian keyboard */
#define DIK_CONVERT         0x79    /* (Japanese keyboard)            */
#define DIK_NOCONVERT       0x7B    /* (Japanese keyboard)            */
#define DIK_YEN             0x7D    /* (Japanese keyboard)            */
#define DIK_ABNT_C2         0x7E    /* Numpad . on Brazilian keyboard */
#define DIK_NUMPADEQUALS    0x8D    /* = on numeric keypad (NEC PC98) */
#define DIK_PREVTRACK       0x90    /* Previous Track (DIK_CIRCUMFLEX on Japanese keyboard) */
#define DIK_AT              0x91    /*                     (NEC PC98) */
#define DIK_COLON           0x92    /*                     (NEC PC98) */
#define DIK_UNDERLINE       0x93    /*                     (NEC PC98) */
#define DIK_KANJI           0x94    /* (Japanese keyboard)            */
#define DIK_STOP            0x95    /*                     (NEC PC98) */
#define DIK_AX              0x96    /*                     (Japan AX) */
#define DIK_UNLABELED       0x97    /*                        (J3100) */
#define DIK_NEXTTRACK       0x99    /* Next Track */
#define DIK_NUMPADENTER     0x9C    /* Enter on numeric keypad */
#define DIK_RCONTROL        0x9D
#define DIK_MUTE            0xA0    /* Mute */
#define DIK_CALCULATOR      0xA1    /* Calculator */
#define DIK_PLAYPAUSE       0xA2    /* Play / Pause */
#define DIK_MEDIASTOP       0xA4    /* Media Stop */
#define DIK_VOLUMEDOWN      0xAE    /* Volume - */
#define DIK_VOLUMEUP        0xB0    /* Volume + */
#define DIK_WEBHOME         0xB2    /* Web home */
#define DIK_NUMPADCOMMA     0xB3    /* , on numeric keypad (NEC PC98) */
#define DIK_DIVIDE          0xB5    /* / on numeric keypad */
#define DIK_SYSRQ           0xB7
#define DIK_RMENU           0xB8    /* right Alt */
#define DIK_PAUSE           0xC5    /* Pause */
#define DIK_HOME            0xC7    /* Home on arrow keypad */
#define DIK_UP              0xC8    /* UpArrow on arrow keypad */
#define DIK_PRIOR           0xC9    /* PgUp on arrow keypad */
#define DIK_LEFT            0xCB    /* LeftArrow on arrow keypad */
#define DIK_RIGHT           0xCD    /* RightArrow on arrow keypad */
#define DIK_END             0xCF    /* End on arrow keypad */
#define DIK_DOWN            0xD0    /* DownArrow on arrow keypad */
#define DIK_NEXT            0xD1    /* PgDn on arrow keypad */
#define DIK_INSERT          0xD2    /* Insert on arrow keypad */
#define DIK_DELETE          0xD3    /* Delete on arrow keypad */
#define DIK_LWIN            0xDB    /* Left Windows key */
#define DIK_RWIN            0xDC    /* Right Windows key */
#define DIK_APPS            0xDD    /* AppMenu key */
#define DIK_POWER           0xDE    /* System Power */
#define DIK_SLEEP           0xDF    /* System Sleep */
#define DIK_WAKE            0xE3    /* System Wake */
#define DIK_WEBSEARCH       0xE5    /* Web Search */
#define DIK_WEBFAVORITES    0xE6    /* Web Favorites */
#define DIK_WEBREFRESH      0xE7    /* Web Refresh */
#define DIK_WEBSTOP         0xE8    /* Web Stop */
#define DIK_WEBFORWARD      0xE9    /* Web Forward */
#define DIK_WEBBACK         0xEA    /* Web Back */
#define DIK_MYCOMPUTER      0xEB    /* My Computer */
#define DIK_MAIL            0xEC    /* Mail */
#define DIK_MEDIASELECT     0xED    /* Media Select */

import mss
import numpy as np
import cv2
import time
import torch
import torch.nn as nn
import torch.optim as optim
import random
import pydirectinput
import matplotlib.pyplot as plt
from collections import deque

print("Wait 3 seconds to switch to the game window...")
time.sleep(3)  # Allow time to switch to the game window

# ---- EDIT THESE TO MATCH YOUR GAME WINDOW ----
region = {'top': 100, 'left': 100, 'width': 800, 'height': 600}  # Set your CS window region here

def grab_screen(region=None):
    with mss.mss() as sct:
        monitor = region if region else sct.monitors[1]
        img = np.array(sct.grab(monitor))
        return img[..., :3]  # Only RGB

class CS16Env:
    def __init__(self, region=None):
        self.region = region
        self.actions = ['w', 'a', 's', 'd']
    def reset(self):
        pass
    def step(self, action):
        if action in ['w', 'a', 's', 'd']:
            pydirectinput.keyDown(action)
            time.sleep(0.01)  # MAX SPEED. Increase if CS doesn't register key.
            pydirectinput.keyUp(action)
        obs = grab_screen(self.region)
        reward = random.random()  # Placeholder, gets overridden
        done = False
        return obs, reward, done, {}
    def get_observation(self):
        return grab_screen(self.region)

def preprocess(frame, size=(84, 84)):
    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)
    frame = cv2.resize(frame, size)
    frame = frame.astype(np.float32) / 255.0
    return frame

frame_stack = deque(maxlen=4)
def reset_stack(frame):
    frame_stack.clear()
    for _ in range(4):
        frame_stack.append(frame)
def stack_frames(new_frame):
    frame_stack.append(new_frame)
    return np.stack(frame_stack, axis=0)

class DQN(nn.Module):
    def __init__(self, in_channels=4, n_actions=4):
        super().__init__()
        self.net = nn.Sequential(
            nn.Conv2d(in_channels, 16, 8, stride=4),
            nn.ReLU(),
            nn.Conv2d(16, 32, 4, stride=2),
            nn.ReLU(),
            nn.Flatten(),
            nn.Linear(32*9*9, 256),
            nn.ReLU(),
            nn.Linear(256, n_actions)
        )
    def forward(self, x):
        return self.net(x)

class ReplayBuffer:
    def __init__(self, capacity):
        self.buffer = []
        self.capacity = capacity
    def push(self, exp):
        if len(self.buffer) >= self.capacity:
            self.buffer.pop(0)
        self.buffer.append(exp)
    def sample(self, batch_size):
        return random.sample(self.buffer, batch_size)

env = CS16Env(region=None)
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
dqn = DQN(in_channels=4, n_actions=len(env.actions)).to(device)
target_dqn = DQN(in_channels=4, n_actions=len(env.actions)).to(device)
target_dqn.load_state_dict(dqn.state_dict())
target_dqn.eval()
optimizer = optim.Adam(dqn.parameters(), lr=1e-4)
buffer = ReplayBuffer(10000)
BATCH_SIZE = 2048
GAMMA = 0.99
rewards = []

obs = preprocess(env.get_observation())
reset_stack(obs)
state = stack_frames(obs)
prev_frame = obs

stuck_counter = 0
STUCK_LIMIT = 20
STUCK_THRESH = 1e-4

TARGET_UPDATE_FREQ = 1000  # steps

for step in range(10000):
    if random.random() < 0.05:
        action_idx = random.randint(0, len(env.actions) - 1)
    else:
        with torch.no_grad():
            state_tensor = torch.tensor(state, dtype=torch.float32).unsqueeze(0).to(device)
            q_vals = dqn(state_tensor)
            action_idx = q_vals.argmax().item()
    action = env.actions[action_idx]
    obs2, _, done, info = env.step(action)
    obs2_proc = preprocess(obs2)
    next_state = stack_frames(obs2_proc)
    diff = np.abs(obs2_proc.astype(np.float32) - prev_frame.astype(np.float32))
    reward = np.mean(diff)
    prev_frame = obs2_proc
    rewards.append(reward)

    if reward < STUCK_THRESH:
        stuck_counter += 1
    else:
        stuck_counter = 0
    if stuck_counter >= STUCK_LIMIT:
        print(f'Agent stuck at step {step}! Resetting episode...')
        done = True
        stuck_counter = 0

    print(f"Step: {step} | Action: {action} | Reward: {reward:.5f} | Done: {done}")
    cv2.imshow('Bot POV', obs2_proc)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        print("User interrupted, quitting.")
        break
    buffer.push((state, action_idx, reward, next_state, done))
    state = next_state

    if len(buffer.buffer) > BATCH_SIZE:
        batch = buffer.sample(BATCH_SIZE)
        s, a, r, s2, d = zip(*batch)
        s = torch.from_numpy(np.stack(s)).float().to(device)
        a = torch.tensor(a).unsqueeze(1).to(device)
        r = torch.tensor(r, dtype=torch.float32).unsqueeze(1).to(device)
        s2 = torch.from_numpy(np.stack(s2)).float().to(device)
        d = torch.tensor(d, dtype=torch.float32).unsqueeze(1).to(device)
        q_vals = dqn(s).gather(1, a)
        with torch.no_grad():
            # THIS LINE IS THE ACTUAL DOUBLE DQN LOGIC:
            next_actions = dqn(s2).max(1)[1].unsqueeze(1)
            next_q = target_dqn(s2).gather(1, next_actions)
        target = r + GAMMA * next_q * (1 - d)
        loss = ((q_vals - target) ** 2).mean()
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        print(f"Train Step: {step} | Loss: {loss.item():.5f}")

        # Update target network every TARGET_UPDATE_FREQ steps
        if step % TARGET_UPDATE_FREQ == 0:
            target_dqn.load_state_dict(dqn.state_dict())
            print("Updated target network.")

    if done:
        print(f"--- Episode finished at step {step}. Resetting... ---")
        obs = preprocess(env.get_observation())
        reset_stack(obs)
        state = stack_frames(obs)
        prev_frame = obs

cv2.destroyAllWindows()
plt.plot(rewards)
plt.xlabel('Step')
plt.ylabel('Reward')
plt.title('Reward per Step')
plt.show()